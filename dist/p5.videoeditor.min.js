!(function (e, t) {
  'object' == typeof exports && 'undefined' != typeof module
    ? t(exports)
    : 'function' == typeof define && define.amd
      ? define(['exports'], t)
      : t(
          (((e = 'undefined' != typeof globalThis ? globalThis : e || self).p5 =
            e.p5 || {}),
          (e.p5.VideoEditor = {}))
        );
})(this, function (e) {
  'use strict';
  var t = 'undefined' != typeof document ? document.currentScript : null;
  class s {
    constructor() {
      this.plugins = [];
    }
    register(e) {
      e
        ? 'string' == typeof e.name && '' !== e.name.trim()
          ? 'string' == typeof e.type && '' !== e.type.trim()
            ? 'function' == typeof e.onLoad
              ? this.plugins.some((t) => t.name === e.name)
                ? console.warn(
                    `Plugin with name "${e.name}" is already registered.`
                  )
                : this.plugins.push(e)
              : console.warn('Invalid plugin: "onLoad" must be a function.', e)
            : console.warn(
                'Invalid plugin: "type" must be a non-empty string.',
                e
              )
          : console.warn(
              'Invalid plugin: "name" must be a non-empty string.',
              e
            )
        : console.warn('Invalid plugin: Plugin object is null or undefined.');
    }
  }
  class i {
    constructor(e, t) {
      ((this.p = e),
        (this.canvas = t),
        (this.width = t.width),
        (this.height = t.height),
        (this.sceneBuffer = e.createGraphics(this.width, this.height, e.WEBGL)),
        (this.effectBuffer = e.createGraphics(
          this.width,
          this.height,
          e.WEBGL
        )),
        (this.shaders = {}),
        (this.shaderPromises = {}),
        (this.postProcessingEffects = []));
    }
    loadShader(e, t) {
      if (this.shaders[e] || this.shaderPromises[e]) return;
      const s = this.p.loadShader('src/shaders/passthrough.vert', t, (t) => {
        ((this.shaders[e] = t),
          delete this.shaderPromises[e],
          console.log(`Shader "${e}" loaded.`));
      });
      this.shaderPromises[e] = s;
    }
    async render(e, t, s) {
      (this.sceneBuffer.clear(), this.sceneBuffer.push());
      const i = new Set();
      for (const e of t) (i.add(e.fromClip), i.add(e.toClip));
      const r = [...e].filter((e) => !i.has(e));
      r.sort((e, t) => e.layer - t.layer);
      for (const e of r) {
        const t = s - e.start;
        for (const s of e.effects) s.apply(e, this.sceneBuffer, t);
        e.render(this.sceneBuffer, t);
      }
      for (const e of t) e.render(this.sceneBuffer, s);
      this.sceneBuffer.pop();
      let o = this.sceneBuffer;
      if (this.postProcessingEffects.length > 0)
        for (const e of this.postProcessingEffects) {
          this.shaderPromises[e.type] && (await this.shaderPromises[e.type]);
          const t = this.shaders[e.type];
          if (t) {
            if (
              (this.effectBuffer.shader(t),
              t.setUniform('u_texture', o),
              e.uniforms)
            )
              for (const [s, i] of Object.entries(e.uniforms))
                t.setUniform(s, i);
            (this.effectBuffer.rect(
              -this.width / 2,
              -this.height / 2,
              this.width,
              this.height
            ),
              (o = this.effectBuffer));
          }
        }
      (this.p.image(o, 0, 0), (this.postProcessingEffects = []));
    }
  }
  class r {
    static critical(e, t) {
      throw (
        console.error(`[p5.videoeditor.js] Critical Error: ${e}`),
        t && console.error('Original Error:', t),
        new Error(`[p5.videoeditor.js] ${e}`)
      );
    }
    static warning(e) {
      console.warn(`[p5.videoeditor.js] Warning: ${e}`);
    }
    static showUserFriendlyError(e) {
      console.error(`[p5.videoeditor.js] An error occurred: ${e.message}`);
    }
  }
  class o {
    constructor(e, t, { frameRate: r = 60, duration: o = 1e4 } = {}) {
      ((this.frameRate = r),
        (this.duration = o),
        (this.clips = []),
        (this.transitions = []),
        (this.time = 0),
        (this.isPlaying = !1),
        (this.isBatching = !1),
        (this.dirtyClips = new Set()),
        (this.needsClipSorting = !1),
        (this.renderEngine = new i(e, t)),
        (this.pluginManager = new s()),
        (this.transitionTypes = new Map()),
        (this.effectTypes = new Map()),
        (this._pluginsLoaded = !1));
    }
    use(e) {
      this.pluginManager.register(e);
    }
    addClip(e) {
      (this.clips.push(e),
        (e.timeline = this),
        this.isBatching
          ? (this.needsClipSorting = !0)
          : this.clips.sort((e, t) => e.layer - t.layer));
    }
    registerTransitionType(e, t) {
      this.transitionTypes.set(e, t);
    }
    registerEffectType(e, t) {
      this.effectTypes.set(e, t);
    }
    addTransition(e) {
      const t = this.transitionTypes.get(e.type);
      if (!t) return (r.warning(`Unknown transition type: ${e.type}`), null);
      const s = new t(e);
      return (this.transitions.push(s), s);
    }
    batch(e) {
      this.isBatching = !0;
      try {
        e();
      } finally {
        ((this.isBatching = !1), this.finalizeBatch());
      }
    }
    finalizeBatch() {
      (this.dirtyClips.forEach((e) => e.finalizeChanges()),
        this.dirtyClips.clear(),
        this.needsClipSorting &&
          (this.clips.sort((e, t) => e.layer - t.layer),
          (this.needsClipSorting = !1)));
    }
    getActiveClips() {
      return this.clips.filter(
        (e) => this.time >= e.start && this.time < e.start + e.duration
      );
    }
    update(e) {
      (this._pluginsLoaded || (this._loadPlugins(), (this._pluginsLoaded = !0)),
        this.isPlaying &&
          ((this.time += e.deltaTime),
          this.time >= this.duration && (this.time %= this.duration)));
      const t = new Set();
      for (const e of this.clips)
        this.time >= e.start && this.time < e.start + e.duration && t.add(e);
      for (const e of this.transitions)
        this.time >= e.start &&
          this.time < e.start + e.duration &&
          (t.add(e.fromClip), t.add(e.toClip));
      for (const s of t) {
        const t = this.time - s.start;
        s.update(e, t);
      }
    }
    async render(e) {
      const t = new Set();
      for (const e of this.clips)
        this.time >= e.start && this.time < e.start + e.duration && t.add(e);
      const s = [];
      for (const e of this.transitions)
        this.time >= e.start &&
          this.time < e.start + e.duration &&
          (s.push(e), t.add(e.fromClip), t.add(e.toClip));
      await this.renderEngine.render(t, s, this.time);
    }
    play() {
      this.isPlaying = !0;
    }
    pause() {
      this.isPlaying = !1;
    }
    seek(e) {
      e >= 0 && e <= this.duration && (this.time = e);
    }
    _loadPlugins() {
      for (const e of this.pluginManager.plugins)
        try {
          e.onLoad(this);
        } catch (t) {
          r.error(`Error loading plugin: ${e.name}`, t);
        }
    }
  }
  class n {
    constructor(e) {
      if (!e || 'function' != typeof e.toDataURL)
        throw new Error(
          'A valid canvas element must be provided to the FrameRecorder.'
        );
      ((this.canvas = e), (this.frames = []));
    }
    start() {
      ((this.frames = []), console.log('Frame recording started.'));
    }
    captureFrame() {
      const e = this.canvas.toDataURL('image/webp', 0.8);
      this.frames.push(e);
    }
    stop() {
      console.log(
        `Frame recording stopped. Total frames captured: ${this.frames.length}`
      );
    }
    getFrames() {
      return this.frames;
    }
  }
  class a {
    constructor({ onProgress: e, onLog: s, onError: i, onComplete: r } = {}) {
      ((this.worker = new Worker(
        new URL(
          './encoder.worker.js',
          'undefined' == typeof document && 'undefined' == typeof location
            ? require('url').pathToFileURL(__filename).href
            : 'undefined' == typeof document
              ? location.href
              : (t && 'SCRIPT' === t.tagName.toUpperCase() && t.src) ||
                new URL('p5.videoeditor.min.js', document.baseURI).href
        ),
        { type: 'module' }
      )),
        (this.onProgress = e),
        (this.onLog = s),
        (this.onError = i),
        (this.onComplete = r),
        (this.worker.onmessage = this.handleWorkerMessage.bind(this)));
    }
    handleWorkerMessage({ data: e }) {
      switch (e.type) {
        case 'log':
          this.onLog && this.onLog(e.data);
          break;
        case 'progress':
          this.onProgress && this.onProgress(e.data);
          break;
        case 'error':
          this.onError && this.onError(new Error(e.data));
          break;
        case 'done':
          const t = new Blob([e.data.buffer], { type: 'video/mp4' });
          this.onComplete && this.onComplete(t);
          break;
        default:
          console.warn(
            'Exporter received unknown message type from worker:',
            e.type
          );
      }
    }
    export(e, t = 30) {
      if (!e || 0 === e.length) {
        const e = new Error('Cannot export without frames.');
        if (!this.onError) throw e;
        return void this.onError(e);
      }
      (this.onLog && this.onLog('Sending frames to export worker...'),
        this.worker.postMessage({ frames: e, frameRate: t }));
    }
    terminate() {
      this.worker.terminate();
    }
  }
  class h {
    constructor(e, t, s) {
      ((this.timeline = e),
        (this.canvas = t),
        (this.container = s),
        (this.frameRecorder = new n(this.canvas)),
        (this.exporter = new a({
          onProgress: this.handleExportProgress.bind(this),
          onComplete: this.handleExportComplete.bind(this),
          onError: this.handleExportError.bind(this),
          onLog: (e) => console.log('Exporter Log:', e),
        })),
        this._createUI());
    }
    _createUI() {
      if (!this.container) return;
      const e = document.createElement('div');
      ((e.style.padding = '10px'),
        (e.style.backgroundColor = '#f0f0f0'),
        (e.style.borderTop = '1.5px solid #ccc'),
        (this.playButton = document.createElement('button')),
        (this.playButton.textContent = 'Play'),
        (this.playButton.onclick = () => {
          this.timeline.isPlaying
            ? (this.pause(), (this.playButton.textContent = 'Play'))
            : (this.play(), (this.playButton.textContent = 'Pause'));
        }),
        e.appendChild(this.playButton),
        (this.exportButton = document.createElement('button')),
        (this.exportButton.textContent = 'Ekspor Video'),
        (this.exportButton.style.marginLeft = '10px'),
        (this.exportButton.onclick = () => this.startExportProcess()),
        e.appendChild(this.exportButton),
        (this.exportStatus = document.createElement('span')),
        (this.exportStatus.style.marginLeft = '15px'),
        (this.exportStatus.style.fontFamily = 'monospace'),
        (this.exportStatus.style.display = 'none'),
        e.appendChild(this.exportStatus),
        this.container.appendChild(e));
    }
    async startExportProcess() {
      ((this.exportButton.disabled = !0),
        (this.playButton.disabled = !0),
        (this.exportStatus.style.display = 'inline'),
        (this.exportStatus.textContent = 'Rendering frames...'),
        this.pause(),
        this.seek(0),
        this.frameRecorder.start());
      const e = this.timeline.frameRate || 30,
        t = 1e3 / e,
        s = this.timeline.duration;
      await new Promise((e) => setTimeout(e, 50));
      for (let e = 0; e <= s; e += t)
        (this.timeline.seek(e),
          this.timeline.render(),
          this.frameRecorder.captureFrame());
      (this.frameRecorder.stop(),
        (this.exportStatus.textContent =
          'Mengenkode video... (ini mungkin perlu waktu)'),
        this.exporter.export(this.frameRecorder.getFrames(), e));
    }
    handleExportProgress(e) {
      this.exportStatus.textContent = `Mengenkode... ${e}%`;
    }
    handleExportComplete(e) {
      this.exportStatus.textContent = 'Ekspor selesai! Memulai pengunduhan...';
      const t = URL.createObjectURL(e),
        s = document.createElement('a');
      ((s.style.display = 'none'),
        (s.href = t),
        (s.download = 'p5-video-export.mp4'),
        document.body.appendChild(s),
        s.click(),
        setTimeout(() => {
          (document.body.removeChild(s),
            URL.revokeObjectURL(t),
            this._resetUIState());
        }, 100));
    }
    handleExportError(e) {
      (console.error('Export failed:', e),
        (this.exportStatus.textContent = `Error: ${e.message}`),
        setTimeout(() => this._resetUIState(), 5e3));
    }
    _resetUIState() {
      ((this.exportButton.disabled = !1),
        (this.playButton.disabled = !1),
        (this.exportStatus.style.display = 'none'),
        (this.exportStatus.textContent = ''));
    }
    play() {
      this.timeline.play();
    }
    pause() {
      this.timeline.pause();
    }
    seek(e) {
      this.timeline.seek(e);
    }
  }
  class l {
    constructor({ frameRateThreshold: e = 45 } = {}) {
      ((this.frameRateThreshold = e), (this.enabled = !0));
    }
    monitor(e) {
      if (!this.enabled || !e) return;
      const t = e.frameRate();
      t < this.frameRateThreshold &&
        console.warn(
          `PerformanceWarning: Frame rate is ${t.toFixed(2)} FPS, which is below the threshold of ${this.frameRateThreshold} FPS.`
        );
    }
    enable() {
      this.enabled = !0;
    }
    disable() {
      this.enabled = !1;
    }
  }
  class p {
    constructor() {
      ((this.cache = new Map()), (this.enabled = !0));
    }
    addAsset(e, t) {
      this.enabled &&
        (this.cache.set(e, t), console.log(`Asset added to cache: ${e}`));
    }
    getAsset(e) {
      return this.cache.get(e);
    }
    clearUnusedAssets(e) {
      if (!this.enabled) return;
      const t = new Set(e);
      let s = 0;
      for (const e of this.cache.keys())
        t.has(e) || (this.cache.delete(e), s++);
      s > 0 && console.log(`Cleared ${s} unused assets from cache.`);
    }
    clearAll() {
      (this.cache.clear(), console.log('Cleared all assets from cache.'));
    }
    enable() {
      this.enabled = !0;
    }
    disable() {
      this.enabled = !1;
    }
  }
  class c {
    constructor(e, t, s = 'linear') {
      ((this.time = e), (this.value = t), (this.easing = s));
    }
  }
  const d = {
    linear: (e) => e,
    easeInQuad: (e) => e * e,
    easeOutQuad: (e) => e * (2 - e),
    easeInOutQuad: (e) => (e < 0.5 ? 2 * e * e : (4 - 2 * e) * e - 1),
    easeInCubic: (e) => e * e * e,
    easeOutCubic: (e) => --e * e * e + 1,
    easeInOutCubic: (e) =>
      e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1,
  };
  class u {
    constructor({
      start: e = 0,
      duration: t = 1e3,
      layer: s = 0,
      assetKey: i = null,
      ...r
    } = {}) {
      ((this.start = e),
        (this.duration = t),
        (this.layer = s),
        (this.assetKey = i),
        (this.timeline = null),
        (this.properties = {
          x: 0,
          y: 0,
          rotation: 0,
          scale: 1,
          opacity: 1,
          ...(r.properties || {}),
        }),
        (this.initialProperties = JSON.parse(JSON.stringify(this.properties))),
        (this.keyframes = {}),
        (this.effects = []));
    }
    addKeyframe(e, t, s, i = 'linear') {
      if (!Object.prototype.hasOwnProperty.call(this.properties, e))
        throw new Error(
          `Property "${e}" is not a recognized or animatable property of this clip.`
        );
      (this.keyframes[e] || (this.keyframes[e] = []),
        this.keyframes[e].push(new c(t, s, i)),
        this.timeline && this.timeline.isBatching
          ? this.timeline.dirtyClips.add(this)
          : this.keyframes[e].sort((e, t) => e.time - t.time));
    }
    addEffect(e = {}) {
      const { type: t } = e;
      if (!this.timeline)
        return (
          r.error('Cannot add an effect to a clip that is not on a timeline.'),
          this
        );
      const s = this.timeline.effectTypes.get(t);
      if (s) {
        const t = new s(e);
        this.effects.push(t);
      } else r.warn(`Effect with type "${t}" not found.`);
      return this;
    }
    finalizeChanges() {
      for (const e in this.keyframes)
        Object.prototype.hasOwnProperty.call(this.keyframes, e) &&
          this.keyframes[e].sort((e, t) => e.time - t.time);
    }
    update(e, t) {
      Object.assign(this.properties, this.initialProperties);
      for (const s in this.keyframes)
        Object.prototype.hasOwnProperty.call(this.keyframes, s) &&
          (this.properties[s] = this._calculateValue(e, s, t));
    }
    _calculateValue(e, t, s) {
      const i = this.keyframes[t];
      if (!i || 0 === i.length) return this.initialProperties[t];
      if (s <= i[0].time) return i[0].value;
      if (s >= i[i.length - 1].time) return i[i.length - 1].value;
      let r = 0,
        o = i.length - 1,
        n = 0;
      for (; r <= o; ) {
        const e = Math.floor((r + o) / 2);
        if (i[e].time < s) ((n = e), (r = e + 1));
        else {
          if (!(i[e].time > s)) return i[e].value;
          o = e - 1;
        }
      }
      const a = i[n],
        h = i[n + 1],
        l = (s - a.time) / (h.time - a.time),
        p = (d[a.easing] || d.linear)(l),
        c = a.value,
        u = h.value;
      return e.Color && c instanceof e.Color && u instanceof e.Color
        ? e.lerpColor(c, u, p)
        : e.lerp(c, u, p);
    }
    render(e, t) {
      (e.push(),
        e.translate(this.properties.x, this.properties.y),
        e.rotate(this.properties.rotation),
        e.scale(this.properties.scale));
    }
  }
  class f extends u {
    constructor(e, t = {}) {
      (super(t),
        (this.text = e),
        (this.properties.fontSize = t.fontSize || 24),
        (this.properties.fill = t.fill || '#ffffff'),
        (this.properties.align = t.align || 'center'));
    }
    render(e, t) {
      (super.render(e, t),
        e.fill(this.properties.fill),
        e.textSize(this.properties.fontSize),
        e.textAlign(this.properties.align, e.CENTER),
        e.text(this.text, 0, 0),
        e.pop());
    }
  }
  class m extends u {
    constructor(e = 'rect', t = {}) {
      (super({
        ...t,
        properties: {
          width: 100,
          height: 100,
          fill: '#ffffff',
          stroke: '#000000',
          strokeWeight: 1,
          ...(t.properties || {}),
        },
      }),
        (this.shapeType = e));
    }
    render(e, t) {
      (super.render(e, t),
        e.fill(this.properties.fill),
        e.stroke(this.properties.stroke),
        e.strokeWeight(this.properties.strokeWeight),
        'rect' === this.shapeType
          ? (e.rectMode(e.CENTER),
            e.rect(0, 0, this.properties.width, this.properties.height))
          : 'ellipse' === this.shapeType &&
            (e.ellipseMode(e.CENTER),
            e.ellipse(0, 0, this.properties.width, this.properties.height)),
        e.pop());
    }
  }
  class g extends u {
    constructor(e, t = {}) {
      ('string' != typeof e || t.assetKey || (t.assetKey = e),
        super({
          ...t,
          properties: {
            width: e ? e.width : 0,
            height: e ? e.height : 0,
            ...(t.properties || {}),
          },
        }),
        (this.image = e));
    }
    render(e, t) {
      (super.render(e, t),
        this.image &&
          (e.imageMode(e.CENTER),
          e.image(
            this.image,
            0,
            0,
            this.properties.width,
            this.properties.height
          )),
        e.pop());
    }
  }
  class y extends u {
    constructor(e, t = {}) {
      'string' != typeof e || t.assetKey || (t.assetKey = e);
      (super({
        ...t,
        properties: { volume: 1, pan: 0, ...(t.properties || {}) },
      }),
        (this.soundFile = e),
        (this._isPlaying = !1));
    }
    update(e, t) {
      if (
        (super.update(e, t),
        !this.soundFile || 'function' != typeof this.soundFile.play)
      )
        return;
      (this.soundFile.setVolume(this.properties.volume),
        this.soundFile.pan(this.properties.pan));
      const s = t >= 0 && t < this.duration;
      if (s && !this._isPlaying) {
        const e = t / 1e3;
        e < this.soundFile.duration() &&
          (this.soundFile.play(),
          this.soundFile.jump(e),
          (this._isPlaying = !0));
      } else
        !s &&
          this._isPlaying &&
          (this.soundFile.stop(), (this._isPlaying = !1));
    }
    render(e, t) {}
  }
  const w = ['http:', 'https:', 'blob:', 'data:'];
  class C extends u {
    constructor(e, t = {}) {
      (super(t),
        'string' == typeof e &&
          e.trim().toLowerCase().startsWith('javascript:') &&
          r.critical(
            'Unsafe video protocol: javascript:. Only safe protocols are allowed.'
          ));
      try {
        const t = new URL(e, document.baseURI);
        w.includes(t.protocol) ||
          r.critical(
            `Unsafe video protocol: ${t.protocol}. Only safe protocols are allowed.`
          );
      } catch (t) {
        r.critical(`Invalid video source URL: ${e}`, t);
      }
      ((this.videoSrc = e),
        (this.isPlaying = !1),
        (this.properties.width = t.width || 1920),
        (this.properties.height = t.height || 1080),
        (this.videoElement = document.createElement('video')),
        (this.videoElement.src = this.videoSrc),
        (this.videoElement.preload = 'auto'),
        (this.videoElement.muted = !0),
        (this.videoElement.playsInline = !0));
    }
    update(e, t) {
      super.update(e, t);
      const s = t / 1e3;
      (Math.abs(this.videoElement.currentTime - s) > 0.05 ||
        this.videoElement.paused) &&
        (this.videoElement.currentTime = s);
      const i = t >= 0 && t < this.duration;
      if (i && !this.isPlaying) {
        const e = this.videoElement.play();
        (void 0 !== e && e.catch((e) => {}), (this.isPlaying = !0));
      } else
        !i &&
          this.isPlaying &&
          (this.videoElement.pause(), (this.isPlaying = !1));
    }
    render(e, t) {
      (super.render(e, t),
        this.videoElement.readyState >= 3 &&
          (e.imageMode(e.CENTER),
          e.image(
            this.videoElement,
            0,
            0,
            this.properties.width,
            this.properties.height
          )),
        e.pop());
    }
  }
  ((e.AudioClip = y),
    (e.ClipBase = u),
    (e.EffectBase = class {
      constructor({ start: e = 0, duration: t = 1e3 } = {}) {
        ((this.start = e), (this.duration = t));
      }
      apply(e, t, s) {
        throw new Error(
          'The "apply()" method must be implemented by a subclass.'
        );
      }
    }),
    (e.ErrorHandler = r),
    (e.ImageClip = g),
    (e.MemoryManager = p),
    (e.PerformanceManager = l),
    (e.PlaybackController = h),
    (e.ShapeClip = m),
    (e.TextClip = f),
    (e.Timeline = o),
    (e.VideoClip = C),
    (e.VideoEditor = class {
      static ErrorHandler = r;
      constructor(e, { canvas: t = null, uiContainer: s = null, ...i } = {}) {
        if (!e)
          throw new Error(
            'A p5.js instance must be provided to the VideoEditor constructor.'
          );
        ((this.timeline = new o(e, t, i)),
          (this.playbackController = new h(this.timeline, t, s)),
          (this.performanceManager = new l(i.performance)),
          (this.memoryManager = new p()),
          (this.play = this.playbackController.play.bind(
            this.playbackController
          )),
          (this.pause = this.playbackController.pause.bind(
            this.playbackController
          )),
          (this.seek = this.playbackController.seek.bind(
            this.playbackController
          )));
      }
      createVideoClip(e, t = {}) {
        const s = new C(e, t);
        return (this.timeline.addClip(s), s);
      }
      createTextClip(e, t = {}) {
        const s = new f(e, t);
        return (this.timeline.addClip(s), s);
      }
      createShapeClip(e, t = {}) {
        const s = new m(e, t);
        return (this.timeline.addClip(s), s);
      }
      createImageClip(e, t = {}) {
        const s = new g(e, t);
        return (this.timeline.addClip(s), s);
      }
      createAudioClip(e, t = {}) {
        const s = new y(e, t);
        return (this.timeline.addClip(s), s);
      }
      cacheAsset(e, t) {
        this.memoryManager.addAsset(e, t);
      }
      update(e) {
        (this.performanceManager.monitor(e), this.timeline.update(e));
        const t = this.timeline
          .getActiveClips()
          .map((e) => e.assetKey)
          .filter((e) => e);
        this.memoryManager.clearUnusedAssets(t);
      }
      async render(e) {
        await this.timeline.render(e);
      }
      showUserFriendlyError(e) {
        r.showUserFriendlyError(e);
      }
    }));
});
//# sourceMappingURL=p5.videoeditor.min.js.map
